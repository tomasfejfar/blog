---
layout: post
status: publish
comments: true
published: true
title: "PhpStorm 101: Code completion"	 
date: '2017-12-23 00:00:00 +0200'
excerpt: Code completion is the cornerstone of effective PhpStorm use. I'll show you some of the ways to help the IDE to understand your code.    
---
  
Code completion is the cornerstone of effective PhpStorm use. I'll show you some of the ways to help the IDE to understand your code. I'll iterate from the basics you probably use already to more advanced tools. 

Tools like refactoring and code inspections fully depend on how well PhpStorm can understand what's happening in your code. But because PHP is a dynamically typed language it much bigger feat compared to say Java, that is strongly-typed.

Like it or not, most of the PHP code in the wild depends on arrays. Most of the codebases you get in touch with were not written in the last year to work with PHP 7.1. No, they would probably work in 5.3 that is long gone (at least officially). Most of it won't be based on <abbr title="Domain Driven Design">DDD</abbr> nor will it adhere to <abbr title="Single Responsibility Principle">SRP</abbr>. 

PhpStorm can be a valuable ally in the fight with messy code. It can help you refactor complexity and clean up the codebase. But it will be only as useful as the information you give it to work with. So let's see how can you point it in the right direction. 

## Describing parameters and return values

### Docblocks

Docblocks are documentation comments. They are not directly parsed by the language parser, but can be accessed both in your code using reflection as well as using external tools (like IDE). You can see typical docblock below. 

```php
<?php
/**
 * @param string $name
 * @param int $age
 * @param Address|null $address
 * @return User
 */
public function createUser($name, $age, $address)
{
    return new User($name, $age, $address);
}
```
The block above the code it telling your IDE that the parameter `$name` is `string`, `$age` is `integer` and `$address` is an instance of `Address` or `null`. Also we let it know that the function returns an instance of `User`. While in this exact case PhpStorm is clever enough to understand that the function returns `User`, in many other cases it would not have a clue. 

Note, that in case of `$address` we allow both instance of `Address` as well as `null` - defined using the pipe character. It's important to describe all possible cases. In this case PhpStorm is now able to let you know you should check for null first, if you do something like `$address->getZipCode()` and suggest methods from `Address` at the same time.

Docblocks are great tool for older code that need to support older PHP versions, but for modern PHP there is a better tool.

### Type declarations

In current PHP 7.2 the above example does not need docblock at all. It can be rewritten to following form:

```php
<?php
declare(strict_types=1);
// ...
public function createUser(string $name, int $age, ?Address $address): User
{
    return new User($name, $age, $address);
}
```
It conveys the same information, but in a PHP language constructs instead of comments. Nice bonus is that the types are enforced when executing the code. If `$age` is defined as integer, you can be sure that it's really an integer. No validation is needed. PHP itself would throw `TypeError` fatal error should any other type be passed to the method. Make sure to [add `strict_types` declaration](http://php.net/manual/en/functions.arguments.php#functions.arguments.type-declaration.strict) to disable type coercing, otherwise PHP would convert `"11 horses"` to `11` as it [normally does](https://3v4l.org/QlLOV) (compare with [strict type behavior](https://3v4l.org/bUAEr)).

## Union types and arrays

Union type is a type that comprises of two different types. For example, let's have 

```php
<?php 
class Address implements ToCountryInterface, ToTownInterface {}
```
 
In case of type definition you can't really use `ToCountryInterface|ToTownInterface`. [At least not yet](https://wiki.php.net/rfc/union_types). This is where you need to resort back to docblocks: 

```php
/**
 * @param ToCountryInterface|ToTownInterface $countryAndTownLocalisableAddress
 */
```

Other case where you need to fall back to docblocks are generics or arrays of objects. A database query may return generic collection of users (`Collection`). Using type declaration you write:

```php
<?php
function getUsers(): Collection {}
```

But that does not convey the information that the collection contains Users. So `$collection->first()->???` won't be autocompleted. You need to fallback to docblocks.

```php
<?php
/**
 * @return User[]|Collection
 */
function getUsers(): Collection {}
```

That way you get autocompletion on both `$collection->count()` as well as `$collection->first()->getUsername()`;


## What if the types are changing in runtime? 

Classes that are factories or service locators return dynamic types based on their input parameters. Observe the following code:

```php
<?php
// there is no way telling what type $logger will be
$logger = $serviceLocator->get('LoggerInterface');
$logger->???
```

But we can suggest the type inline using documentation comment. 

```php
<?php
/** @var LoggerInterface $logger */
$logger = $serviceLocator->get('LoggerInterface');
$logger->log(/* code completion works */);
```

This approach is very compatible and many other tools will be able to understand it. But keep in mind that it's still comment-based, so _it may get outdated or overlooked when refactoring_.  

## What about magic methods? 

```php
<?php
/**
 * @property-read $username
 * @property $name
 * @property-write $password
 * @method void reset()
 * @method static Config factory()
 */
class Config {
    private $config = ['username' => 'john', 'name' => 'John Doe', 'password' => '123456'];
    
    public function __get($property){
        if ($property === 'password') {
            return null; // you can't read password
        }
        return $this->config[$property];
    }
    
    public function __set($property, $value){
        if ($property === 'username') {
			return null; // you can't set username
		}
		return $this->config[$property];
    }
    
    public function __call($method, $arguments){
        if ($method === 'reset') {
            $this->config = [];
        }
    }
    
    public static function __callStatic($method, $arguments){
        if ($method === 'factory') {
            return new self();
        }
    }
}
```

In the (admitedly shitty) code above you can see all the options you have for hinting the behavior of magic methods. 

* `@property-read` - means that the property can be read. You will get autocompletion for `$username = $config->username;`, but if you try to write into the property, you'll get an error.
* `@property-write` - means that the property can be written. You will get autocompletion for `$config->password = 'dummy';` but if you try to read the property, you'll get an error
* `@property` - combines the two above (read and write)
* `@method` - means there is a valid method to be called on the class. In this case `$config->reset()` will be autocompleted. 
* `@method static` - means there is a valid static method to be called on the class. In this case `Config::factory()` will be autocompleted along with the return type. So you can get autocompletion for something like `Config::factory()->reset()` 

## PhpStorm meta file

Last, but not least there is [`.phpstorm.meta.php` file](https://confluence.jetbrains.com/display/PhpStorm/PhpStorm+Advanced+Metadata). 

```php

<?php
// in .phpstorm.meta.php\myframework.meta.php
namespace PHPSTORM_META {
  override(\ServiceLocator::get(0),
    map([
      'foo' => \FooInterface::class, // if called get('foo'), return FooInterface
      \ToTownInterface::class => \User::class, // if called get(\ToTownInterface::class), return User
      // if called get('AnythingElse'), return AnythingElse (default) 
    ])
  );
  
  override(\IteratorGenerator::get(0),
    map([
      // "@" is replaced with whatever was passed to the method call  
      '' => '@Iterator|\Iterator' // if called get('User'), return UserIterator|Iterator
    ])
  );
}
```

Unfortunately you can override the behavior only for the first parameter of the call. It's arbitrary limitation of the current implementation in PhpStorm, that may change in the future. You can see that the format itself is ready [from the stubs](https://github.com/JetBrains/phpstorm-stubs/blob/master/meta/.phpstorm.meta.php). 
